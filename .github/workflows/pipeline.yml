name: Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'public/**'
      - '.github/workflows/pages.yml'
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'public/**'
  workflow_dispatch:
    inputs:
      version_override:
        description: 'Version override (e.g., v1.0.0, or leave blank for auto-calculation)'
        required: false
        type: string
      version_type:
        description: 'Version bump type (if not overriding)'
        required: false
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

permissions:
  contents: write
  packages: read
  security-events: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ====================
  # STAGE 1: VALIDATE
  # ====================
  
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        clean: true

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: 'stable'
        check-latest: true
        cache: false

    - name: Download dependencies
      run: go mod download

    - name: Check formatting
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "Code is not formatted. Please run 'gofmt -s -w .'"
          gofmt -s -l .
          exit 1
        fi

    - name: Run go vet
      run: go vet ./...

    - name: Check go mod tidy
      run: |
        go mod tidy
        if ! git diff --exit-code go.mod go.sum; then
          echo "go.mod or go.sum is not tidy. Please run 'go mod tidy'"
          exit 1
        fi

    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v9
      with:
        version: v2.8
        args: --config=.golangci.yml

  test:
    name: Test (${{ matrix.os }}, Go ${{ matrix.go-version }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
        go-version: ['1.23', 'stable']
        exclude:
          # Only test latest Go on macOS to save CI minutes
          - os: macos-latest
            go-version: '1.23'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        clean: true

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ matrix.go-version }}
        check-latest: true
        cache: false

    - name: Download dependencies
      run: |
        go mod download
        go mod verify

    - name: Run unit tests
      run: go test -v -race -timeout=5m ./pkg/... ./internal/...

    - name: Run integration tests
      run: go test -v -timeout=2m ./test/integration/...

    - name: Run functional tests
      run: make test-functional

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        clean: true

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: 'stable'
        check-latest: true
        cache: false

    - name: Run govulncheck
      run: |
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck ./...

    - name: Run gosec
      run: |
        go install github.com/securego/gosec/v2/cmd/gosec@latest
        # Exclude rules that are false positives for CLI tools (matches .golangci.yml):
        # G115: integer overflow (file size conversions)
        # G204: subprocess with variable (expected in CLI)
        # G304: file inclusion via variable (expected in file management CLI)
        # G407: false positive - flags make([]byte, N) as hardcoded even when filled with rand.Read()
        gosec -exclude=G115,G204,G304,G407 -fmt sarif -out results.sarif ./...
        
    - name: Upload SARIF file
      uses: github/codeql-action/upload-sarif@v4
      continue-on-error: true
      with:
        sarif_file: results.sarif

  build-verify:
    name: Build Verification
    runs-on: ubuntu-latest
    needs: [lint, test, security]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        clean: true

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: 'stable'
        check-latest: true
        cache: false

    - name: Download dependencies
      run: go mod download

    - name: Build for current platform
      run: |
        make build
        ./goingenv --version

    - name: Test cross-compilation
      run: |
        echo "Testing cross-compilation for all supported platforms..."
        
        # Linux
        GOOS=linux GOARCH=amd64 go build -o goingenv-linux-amd64 ./cmd/goingenv
        GOOS=linux GOARCH=arm64 go build -o goingenv-linux-arm64 ./cmd/goingenv
        
        # macOS
        GOOS=darwin GOARCH=amd64 go build -o goingenv-darwin-amd64 ./cmd/goingenv
        GOOS=darwin GOARCH=arm64 go build -o goingenv-darwin-arm64 ./cmd/goingenv
        
        # Verify binaries exist
        ls -la goingenv-*
        
        echo "All platforms build successfully"

  test-install-script:
    name: Test Install Script (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: [lint, test, security]
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Test install script syntax
      run: |
        bash -n install.sh
        echo "Install script syntax is valid"

    - name: Test install script help
      run: |
        chmod +x install.sh
        ./install.sh --help

    - name: Test install script dry run
      run: |
        DEBUG=1 NO_SUDO=1 SKIP_SHELL_INTEGRATION=1 ./install.sh --version v99.99.99 || echo "Expected failure for non-existent version"

  # ====================
  # STAGE 2: BUILD (main branch only)
  # ====================

  check-release:
    name: Check Release Status
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    needs: [build-verify, test-install-script]
    outputs:
      should-release: ${{ steps.check-commit.outputs.should-release }}
      next-version: ${{ steps.calculate-version.outputs.next-version }}
      version-type: ${{ steps.check-commit.outputs.version-type }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check commit message for release flags
      id: check-commit
      env:
        COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "Manual release triggered"
          echo "should-release=true" >> $GITHUB_OUTPUT

          # Use input version type or default to patch
          VERSION_TYPE="${{ github.event.inputs.version_type || 'patch' }}"
          echo "version-type=$VERSION_TYPE" >> $GITHUB_OUTPUT
          echo "Version type: $VERSION_TYPE (from input)"
        else
          COMMIT_MSG="$COMMIT_MESSAGE"
          echo "Commit message: $COMMIT_MSG"

          # Check for release flag - REQUIRED for auto-release
          if ! echo "$COMMIT_MSG" | grep -q '\[release\]'; then
            echo "should-release=false" >> $GITHUB_OUTPUT
            echo "No release - [release] flag not found in commit message"
            exit 0
          fi

          # Check for version override flags
          if echo "$COMMIT_MSG" | grep -q '\[major\]'; then
            echo "version-type=major" >> $GITHUB_OUTPUT
            echo "Major version bump requested"
          elif echo "$COMMIT_MSG" | grep -q '\[minor\]'; then
            echo "version-type=minor" >> $GITHUB_OUTPUT
            echo "Minor version bump requested"
          else
            echo "version-type=patch" >> $GITHUB_OUTPUT
            echo "Patch version bump (default)"
          fi

          echo "should-release=true" >> $GITHUB_OUTPUT
          echo "Release triggered by [release] flag"
        fi

    - name: Calculate next version
      if: steps.check-commit.outputs.should-release == 'true'
      id: calculate-version
      run: |
        # Check for manual version override
        if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version_override }}" ]]; then
          OVERRIDE_VERSION="${{ github.event.inputs.version_override }}"
          # Remove v prefix if present
          NEXT_VERSION=${OVERRIDE_VERSION#v}
          echo "Using version override: v$NEXT_VERSION"
        else
          VERSION_TYPE="${{ steps.check-commit.outputs.version-type }}"
          
          # Get latest stable release tag
          LATEST_TAG=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
          
          if [[ -z "$LATEST_TAG" ]]; then
            echo "No previous stable releases found, starting with v1.0.0"
            NEXT_VERSION="1.0.0"
          else
            echo "Latest stable release: $LATEST_TAG"
            
            # Extract version numbers
            CURRENT_VERSION=${LATEST_TAG#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
            
            # Calculate next version based on type
            case "$VERSION_TYPE" in
              major)
                NEXT_VERSION="$((MAJOR + 1)).0.0"
                ;;
              minor)
                NEXT_VERSION="$MAJOR.$((MINOR + 1)).0"
                ;;
              patch)
                NEXT_VERSION="$MAJOR.$MINOR.$((PATCH + 1))"
                ;;
              *)
                echo "Invalid version type: $VERSION_TYPE"
                exit 1
                ;;
            esac
          fi
        fi
        
        echo "next-version=$NEXT_VERSION" >> $GITHUB_OUTPUT
        echo "Next version will be: v$NEXT_VERSION"
        
        # Check if this version already exists
        if git tag | grep -q "^v$NEXT_VERSION$"; then
          echo "Version v$NEXT_VERSION already exists!"
          exit 1
        fi
        
        echo "Version v$NEXT_VERSION is available"

  build-release:
    name: Build Release (${{ matrix.goos }}-${{ matrix.goarch }})
    runs-on: ubuntu-latest
    needs: check-release
    if: needs.check-release.outputs.should-release == 'true'
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        clean: true

    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: 'stable'
        check-latest: true
        cache: false

    - name: Build binary
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
        VERSION: ${{ needs.check-release.outputs.next-version }}
        BUILD_TIME: ${{ github.event.head_commit.timestamp }}
        GIT_COMMIT: ${{ github.sha }}
      run: |
        echo "Building for $GOOS/$GOARCH..."
        
        # Build with release flags
        go build \
          -trimpath \
          -ldflags="-s -w -X main.Version=v$VERSION -X main.BuildTime=$BUILD_TIME -X main.GitCommit=$GIT_COMMIT" \
          -o goingenv-$GOOS-$GOARCH \
          ./cmd/goingenv
        
        # Set execute permissions
        chmod +x goingenv-$GOOS-$GOARCH
        
        # Verify binary (only for Linux AMD64 since we're running on Ubuntu)
        if [[ "$GOOS" == "linux" && "$GOARCH" == "amd64" ]]; then
          echo "Verifying Linux AMD64 binary..."
          ./goingenv-$GOOS-$GOARCH --version
        else
          echo "Cross-compiled binary for $GOOS/$GOARCH (verification skipped - incompatible platform)"
        fi
        
        echo "Binary built successfully"

    - name: Create archive
      run: |
        ARCHIVE_NAME="goingenv-v${{ needs.check-release.outputs.next-version }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz"
        
        # Copy binary to standard name for archive
        cp goingenv-${{ matrix.goos }}-${{ matrix.goarch }} goingenv
        
        # Create archive with standard binary name
        tar -czf "$ARCHIVE_NAME" goingenv
        
        # Generate checksum
        sha256sum "$ARCHIVE_NAME" > "$ARCHIVE_NAME.sha256"
        
        echo "Archive: $ARCHIVE_NAME"
        echo "Size: $(du -h $ARCHIVE_NAME | cut -f1)"
        echo "SHA256: $(cat $ARCHIVE_NAME.sha256)"

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: goingenv-v${{ needs.check-release.outputs.next-version }}-${{ matrix.goos }}-${{ matrix.goarch }}
        path: |
          goingenv-v${{ needs.check-release.outputs.next-version }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz
          goingenv-v${{ needs.check-release.outputs.next-version }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz.sha256

  # ====================
  # STAGE 3: RELEASE (main branch only, with release flag)
  # ====================

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [check-release, build-release]
    if: needs.check-release.outputs.should-release == 'true'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: dist/

    - name: Prepare release assets
      run: |
        echo "Organizing release assets..."
        mkdir -p release-assets
        
        # Move all archives to release-assets directory
        find dist/ -name "*.tar.gz" -exec mv {} release-assets/ \;
        find dist/ -name "*.sha256" -exec mv {} release-assets/ \;
        
        # Create combined checksums file
        cd release-assets
        cat *.sha256 > checksums.txt
        rm *.sha256
        
        echo "Release assets:"
        ls -la
        
        echo "Checksums:"
        cat checksums.txt

    - name: Create versioned install script
      run: |
        VERSION="v${{ needs.check-release.outputs.next-version }}"
        echo "Creating versioned install.sh with embedded version: $VERSION"

        # Copy install.sh to release assets
        cp install.sh release-assets/install.sh

        # Embed the version in SCRIPT_VERSION variable
        sed -i 's/^SCRIPT_VERSION=""$/SCRIPT_VERSION="'"$VERSION"'"/' release-assets/install.sh

        # Verify the replacement worked
        if grep -q "SCRIPT_VERSION=\"$VERSION\"" release-assets/install.sh; then
          echo "Successfully embedded version $VERSION in install.sh"
        else
          echo "ERROR: Failed to embed version in install.sh"
          grep "SCRIPT_VERSION=" release-assets/install.sh
          exit 1
        fi

        # Make executable
        chmod +x release-assets/install.sh

        echo "Versioned install.sh created:"
        grep "SCRIPT_VERSION=" release-assets/install.sh

    - name: Create release tag
      env:
        COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
      run: |
        VERSION="v${{ needs.check-release.outputs.next-version }}"
        echo "Creating release tag: $VERSION"

        # Create annotated tag with release information
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          TRIGGER_MSG="Manual release via GitHub Actions"
        else
          TRIGGER_MSG="$COMMIT_MESSAGE"
        fi

        git tag -a "$VERSION" -m "Release $VERSION

        Released from main branch
        Commit: ${{ github.sha }}
        Triggered by: $TRIGGER_MSG

        This release was created automatically by GitHub Actions"

        # Push the tag
        git push origin "$VERSION"

        echo "Tag $VERSION created and pushed"

    - name: Get previous tag
      id: get_previous_tag
      run: |
        PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+' | head -2 | tail -1)
        echo "previous_tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
        echo "Previous tag: $PREVIOUS_TAG"

    - name: Determine source branch
      id: get_branch
      run: |
        # Get the branch that contains this tag
        BRANCH=$(git branch -r --contains ${{ github.sha }} | grep -v HEAD | head -1 | sed 's/.*\///')
        if [[ -z "$BRANCH" ]]; then
          BRANCH="main"  # fallback to main
        fi
        echo "branch=$BRANCH" >> $GITHUB_OUTPUT
        echo "Source branch: $BRANCH"

    - name: Generate release notes
      id: release_notes
      run: |
        VERSION="v${{ needs.check-release.outputs.next-version }}"
        PREVIOUS_TAG="${{ steps.get_previous_tag.outputs.previous_tag }}"
        
        # Get auto-generated release notes from GitHub API if previous tag exists
        if [[ -n "$PREVIOUS_TAG" ]]; then
          RELEASE_NOTES=$(curl -s -H "Authorization: token ${{ github.token }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/generate-notes" \
            -d "{\"tag_name\":\"$VERSION\",\"previous_tag_name\":\"$PREVIOUS_TAG\"}" \
            | jq -r '.body' || echo "**Changes:** See commit history for details.")
        else
          RELEASE_NOTES="**Initial Release**"
        fi
        
        # Create installation instructions
        {
          echo "## Installation"
          echo ""
          echo "**Quick Install (Always Latest):**"
          echo '```bash'
          echo "curl -sSL https://raw.githubusercontent.com/${{ github.repository }}/main/install.sh | bash"
          echo '```'
          echo ""
          echo "**Install This Exact Version (Reproducible):**"
          echo '```bash'
          echo "# Downloads install.sh from release assets with embedded version"
          echo "curl -sSL https://github.com/${{ github.repository }}/releases/download/$VERSION/install.sh | bash"
          echo '```'
          echo ""
          echo "**Install Any Specific Version:**"
          echo '```bash'
          echo "curl -sSL https://raw.githubusercontent.com/${{ github.repository }}/main/install.sh | bash -s -- --version $VERSION"
          echo '```'
          echo ""
          echo "**Upgrade with Cleanup:**"
          echo '```bash'
          echo "curl -sSL https://raw.githubusercontent.com/${{ github.repository }}/main/install.sh | bash -s -- --cleanup-all"
          echo '```'
          echo ""
          echo "**Manual Download:**"
          echo "Download the appropriate binary for your platform from the assets below."
          echo ""
          echo "## Verification"
          echo ""
          echo "Verify your download with SHA256 checksums:"
          echo '```bash'
          echo "sha256sum -c checksums.txt"
          echo '```'
          echo ""
          echo "---"
          echo ""
        } > release_notes.md

        # Append the auto-generated notes
        echo "$RELEASE_NOTES" >> release_notes.md
        
        # Set output for use in release creation
        echo "RELEASE_BODY<<EOF" >> $GITHUB_ENV
        cat release_notes.md >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

    - name: Check if prerelease
      id: check_prerelease
      run: |
        VERSION="v${{ needs.check-release.outputs.next-version }}"
        
        if [[ "$VERSION" =~ -.*$ ]]; then
          echo "prerelease=true" >> $GITHUB_OUTPUT
          echo "This is a prerelease"
        else
          echo "prerelease=false" >> $GITHUB_OUTPUT
          echo "This is a stable release"
        fi

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ needs.check-release.outputs.next-version }}
        name: GoingEnv v${{ needs.check-release.outputs.next-version }}
        body: ${{ env.RELEASE_BODY }}
        draft: false
        prerelease: ${{ steps.check_prerelease.outputs.prerelease }}
        files: release-assets/*
        generate_release_notes: false
        make_latest: ${{ steps.check_prerelease.outputs.prerelease == 'false' }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  post-release-validation:
    name: Post-Release Validation (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    needs: [check-release, create-release]
    if: needs.check-release.outputs.should-release == 'true'
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Wait for release to be available
      run: |
        echo "Waiting for release to be available..."
        VERSION="v${{ needs.check-release.outputs.next-version }}"
        for i in {1..60}; do
          if curl -sSf "https://github.com/${{ github.repository }}/releases/download/$VERSION/checksums.txt" >/dev/null; then
            echo "Release is available"
            break
          fi
          echo "Attempt $i/60: Release not yet available, waiting 10s..."
          sleep 10
        done

    - name: Test install script with new release
      run: |
        echo "Testing install script with new release..."
        
        # Test install script
        chmod +x install.sh
        
        # Test in temporary directory
        TEMP_DIR=$(mktemp -d)
        cd "$TEMP_DIR"
        
        # Download and test install script
        curl -sSL "https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/install.sh" -o install.sh
        chmod +x install.sh
        
        # Test with new version
        VERSION="v${{ needs.check-release.outputs.next-version }}"
        INSTALL_DIR="$TEMP_DIR/bin" NO_SUDO=1 SKIP_SHELL_INTEGRATION=1 YES=1 \
          ./install.sh --version $VERSION
        
        # Verify installation
        if [[ -f "$TEMP_DIR/bin/goingenv" ]]; then
          echo "Binary installed successfully"
          "$TEMP_DIR/bin/goingenv" --version
          "$TEMP_DIR/bin/goingenv" --help >/dev/null
          echo "Basic functionality verified"
        else
          echo "Binary not found after installation"
          exit 1
        fi
        
        # Cleanup
        rm -rf "$TEMP_DIR"

    - name: Test direct download
      run: |
        echo "Testing direct binary download..."
        
        # Determine platform
        case "${{ runner.os }}" in
          Linux)
            PLATFORM="linux-amd64"
            ;;
          macOS)
            if [[ "$(uname -m)" == "arm64" ]]; then
              PLATFORM="darwin-arm64"
            else
              PLATFORM="darwin-amd64"
            fi
            ;;
        esac
        
        echo "Testing platform: $PLATFORM"
        
        # Download and test binary
        VERSION="v${{ needs.check-release.outputs.next-version }}"
        ARCHIVE_URL="https://github.com/${{ github.repository }}/releases/download/$VERSION/goingenv-$VERSION-$PLATFORM.tar.gz"
        
        curl -sSL "$ARCHIVE_URL" -o test-binary.tar.gz
        tar -xzf test-binary.tar.gz
        
        # Test binary (archive now contains just 'goingenv')
        ./goingenv --version
        ./goingenv --help >/dev/null
        
        echo "Direct download and execution successful"

  # ====================
  # NOTIFICATIONS
  # ====================

  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [check-release, post-release-validation]
    if: success() && needs.check-release.outputs.should-release == 'true'
    steps:
    - name: Success notification
      run: |
        VERSION="v${{ needs.check-release.outputs.next-version }}"
        echo "Release $VERSION completed successfully!"
        echo ""
        echo "Release URL: https://github.com/${{ github.repository }}/releases/tag/$VERSION"
        echo "Install command: curl -sSL https://raw.githubusercontent.com/${{ github.repository }}/main/install.sh | bash"
        echo ""
        echo "All validation checks passed"
        echo "Binaries are available for download"
        echo "Install script works with new release"

  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: [lint, test, security, build-verify, test-install-script, check-release, build-release, create-release, post-release-validation]
    if: failure()
    steps:
    - name: Failure notification
      run: |
        echo "Pipeline failed!"
        echo ""
        echo "Check the workflow logs for details:"
        echo "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        echo ""
        echo "Common issues:"
        echo "- Test failures (unit, integration, or functional)"
        echo "- Linting failures (formatting, vet, golangci-lint)"
        echo "- Security vulnerabilities detected"
        echo "- Build failures on specific platforms"
        echo "- Version calculation failed"
        echo "- Tag already exists"
        echo "- Release creation or asset upload issues"
        echo "- Post-release validation failures"
        echo ""
        echo "To trigger releases, include [release] in commit message"
        echo "To control version bump, use [major], [minor], or leave blank for patch"
        echo "Use workflow_dispatch for manual releases via GitHub Actions UI"
